// cmd/cimianstatus/main.go - Native Windows GUI status display for Cimian installation progress

package main

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"
	"syscall"
	"time"
	"unsafe"

	"github.com/gonutz/w32"
)

// StatusMessage represents incoming messages from the CLI
type StatusMessage struct {
	Type    string `json:"type"`
	Data    string `json:"data,omitempty"`
	Percent int    `json:"percent,omitempty"`
	Error   bool   `json:"error,omitempty"`
}

// StatusState holds the current status information
type StatusState struct {
	mu            sync.RWMutex
	StatusText    string
	DetailText    string
	ProgressValue int
	ShowProgress  bool
	HasError      bool
	LogAvailable  bool
	LogPath       string
	LastRunTime   string // Store the last successful run time
}

// CimianStatusApp holds the application state
type CimianStatusApp struct {
	tcpListener    net.Listener
	ctx            context.Context
	cancel         context.CancelFunc
	state          *StatusState
	backgroundMode bool

	// Windows GUI elements
	hwnd         w32.HWND
	statusLabel  w32.HWND
	detailLabel  w32.HWND
	progressBar  w32.HWND
	logsButton   w32.HWND
	runNowButton w32.HWND

	// Fonts
	aptosFont     w32.HFONT
	aptosBoldFont w32.HFONT

	// Window class
	className string
}

// Windows constants
const (
	IDC_STATUS_LABEL   = 1001
	IDC_DETAIL_LABEL   = 1002
	IDC_PROGRESS_BAR   = 1004
	IDC_LOGS_BUTTON    = 1005
	IDC_RUN_NOW_BUTTON = 1006
)

// Window procedure for handling Windows messages
func (app *CimianStatusApp) wndProc(hwnd w32.HWND, msg uint32, wParam uintptr, lParam uintptr) uintptr {
	switch msg {
	case w32.WM_CREATE:
		log.Println("WM_CREATE received, creating controls...")
		app.createControls(hwnd)
		log.Println("Controls created successfully")
		return 0

	case w32.WM_COMMAND:
		switch w32.LOWORD(uint32(wParam)) {
		case IDC_LOGS_BUTTON:
			go app.showLogs() // Run in goroutine to avoid blocking UI
		case IDC_RUN_NOW_BUTTON:
			app.runNow() // Call directly since we're on main thread
		}
		return 0

	case w32.WM_CTLCOLORSTATIC:
		// Enhanced styling for static controls with seamless background
		gdi32 := syscall.NewLazyDLL("gdi32.dll")
		setTextColor := gdi32.NewProc("SetTextColor")
		setBkMode := gdi32.NewProc("SetBkMode")

		// Get the control ID to apply different colors
		controlHwnd := w32.HWND(lParam)
		controlID := 0

		// Check which control this is by comparing HWND
		switch controlHwnd {
		case app.statusLabel:
			controlID = IDC_STATUS_LABEL
		case app.detailLabel:
			controlID = IDC_DETAIL_LABEL
		}

		switch controlID {
		case IDC_STATUS_LABEL:
			// Main status text - use darker color for emphasis
			setTextColor.Call(wParam, uintptr(0x003366)) // Dark blue
		case IDC_DETAIL_LABEL:
			// Secondary text - use gray color
			setTextColor.Call(wParam, uintptr(0x666666)) // Medium gray
		default:
			// Default black text for titles and other controls
			setTextColor.Call(wParam, uintptr(0x000000)) // Black
		}

		// Set background to transparent mode for seamless appearance
		setBkMode.Call(wParam, uintptr(1)) // TRANSPARENT mode - no background boxing

		// Return system dialog background brush for seamless integration
		return uintptr(w32.GetSysColorBrush(w32.COLOR_BTNFACE))

	case w32.WM_CTLCOLORBTN:
		// Modern button styling
		gdi32 := syscall.NewLazyDLL("gdi32.dll")
		setBkMode := gdi32.NewProc("SetBkMode")
		setBkMode.Call(wParam, uintptr(1)) // TRANSPARENT mode
		return uintptr(w32.GetStockObject(w32.NULL_BRUSH))

	case w32.WM_DRAWITEM:
		// Custom button drawing for modern appearance (if owner-drawn buttons are used)
		// This would require more complex implementation for fully custom buttons

	case w32.WM_CLOSE:
		app.cancel()
		w32.DestroyWindow(hwnd)

	case w32.WM_USER + 1:
		// Custom message for UI updates from background threads
		// This is non-blocking and safe to call from any thread
		app.updateUI()
		return 0

	case w32.WM_USER + 2:
		// Custom message to re-enable the Run Now button
		w32.EnableWindow(app.runNowButton, true)
		w32.SetWindowText(app.runNowButton, "ðŸ”„ Run Now")
		w32.InvalidateRect(app.runNowButton, nil, true)
		w32.UpdateWindow(app.runNowButton)
		return 0

	case w32.WM_DESTROY:
		// Clean up fonts
		if app.aptosFont != 0 {
			w32.DeleteObject(w32.HGDIOBJ(app.aptosFont))
		}
		if app.aptosBoldFont != 0 {
			w32.DeleteObject(w32.HGDIOBJ(app.aptosBoldFont))
		}
		w32.PostQuitMessage(0)

	default:
		return w32.DefWindowProc(hwnd, msg, wParam, lParam)
	}
	return 0
}

// createFonts creates the Aptos fonts for the application
func (app *CimianStatusApp) createFonts() {
	gdi32 := syscall.NewLazyDLL("gdi32.dll")
	createFont := gdi32.NewProc("CreateFontW")

	// Create standard Aptos font (11pt - 25% larger than 9pt)
	aptosName, _ := syscall.UTF16PtrFromString("Aptos")
	ret, _, _ := createFont.Call(
		uintptr(^uintptr(15-1)),          // Height (negative for character height, using two's complement) - 25% larger
		uintptr(0),                       // Width (0 = default)
		uintptr(0),                       // Escapement
		uintptr(0),                       // Orientation
		uintptr(w32.FW_NORMAL),           // Weight
		uintptr(0),                       // Italic
		uintptr(0),                       // Underline
		uintptr(0),                       // StrikeOut
		uintptr(w32.DEFAULT_CHARSET),     // CharSet
		uintptr(w32.OUT_DEFAULT_PRECIS),  // OutputPrecision
		uintptr(w32.CLIP_DEFAULT_PRECIS), // ClipPrecision
		uintptr(w32.CLEARTYPE_QUALITY),   // Quality (use ClearType for modern look)
		uintptr(w32.DEFAULT_PITCH|w32.FF_DONTCARE), // PitchAndFamily
		uintptr(unsafe.Pointer(aptosName)))         // FaceName
	app.aptosFont = w32.HFONT(ret)

	// Create bold Aptos font for titles (13pt - 25% larger than 10pt)
	ret2, _, _ := createFont.Call(
		uintptr(^uintptr(17-1)),          // Height (slightly larger for titles, using two's complement) - 25% larger
		uintptr(0),                       // Width (0 = default)
		uintptr(0),                       // Escapement
		uintptr(0),                       // Orientation
		uintptr(w32.FW_BOLD),             // Weight (bold)
		uintptr(0),                       // Italic
		uintptr(0),                       // Underline
		uintptr(0),                       // StrikeOut
		uintptr(w32.DEFAULT_CHARSET),     // CharSet
		uintptr(w32.OUT_DEFAULT_PRECIS),  // OutputPrecision
		uintptr(w32.CLIP_DEFAULT_PRECIS), // ClipPrecision
		uintptr(w32.CLEARTYPE_QUALITY),   // Quality (use ClearType for modern look)
		uintptr(w32.DEFAULT_PITCH|w32.FF_DONTCARE), // PitchAndFamily
		uintptr(unsafe.Pointer(aptosName)))         // FaceName
	app.aptosBoldFont = w32.HFONT(ret2)

	log.Printf("Created Aptos fonts: regular=%v, bold=%v", app.aptosFont, app.aptosBoldFont)
}

// createControls creates the Windows controls (labels, progress bar, button)
func (app *CimianStatusApp) createControls(hwnd w32.HWND) {
	log.Println("Creating controls...")
	hInstance := w32.GetModuleHandle("")

	// Create Aptos fonts
	app.createFonts()

	// Create simple static controls with minimal styling
	staticClass, _ := syscall.UTF16PtrFromString("STATIC")
	buttonClass, _ := syscall.UTF16PtrFromString("BUTTON")
	progressClass, _ := syscall.UTF16PtrFromString("msctls_progress32")

	// Create status label (main status message) - moved up since title is removed
	statusText, _ := syscall.UTF16PtrFromString("Ready")
	app.statusLabel = w32.CreateWindowEx(
		0,
		staticClass,
		statusText,
		w32.WS_VISIBLE|w32.WS_CHILD|w32.SS_CENTER,
		20, 30, 460, 38, // Moved up from 80 to 30, increased height for emphasis
		hwnd, IDC_STATUS_LABEL, hInstance, nil)
	log.Printf("Status label created: %v", app.statusLabel)
	// Set Aptos font for status
	w32.SendMessage(app.statusLabel, w32.WM_SETFONT, uintptr(app.aptosFont), 1)

	// Create detail label (last run time)
	detailText, _ := syscall.UTF16PtrFromString("Last run: Never")
	app.detailLabel = w32.CreateWindowEx(
		0,
		staticClass,
		detailText,
		w32.WS_VISIBLE|w32.WS_CHILD|w32.SS_CENTER,
		20, 80, 460, 25, // Moved up from 120 to 80
		hwnd, IDC_DETAIL_LABEL, hInstance, nil)
	log.Printf("Detail label created: %v", app.detailLabel)
	// Set Aptos font for detail
	w32.SendMessage(app.detailLabel, w32.WM_SETFONT, uintptr(app.aptosFont), 1)

	// Create progress bar
	emptyTextProgress, _ := syscall.UTF16PtrFromString("")
	app.progressBar = w32.CreateWindowEx(
		0,
		progressClass,
		emptyTextProgress,
		w32.WS_VISIBLE|w32.WS_CHILD|0x01, // PBS_SMOOTH style
		20, 120, 460, 25,                 // Moved up from 160 to 120
		hwnd, IDC_PROGRESS_BAR, hInstance, nil)
	log.Printf("Progress bar created: %v", app.progressBar)

	// Set progress bar range
	w32.SendMessage(app.progressBar, 0x401, 0, uintptr(100)<<16) // PBM_SETRANGE (0-100)

	// Create Show Logs button
	buttonText, _ := syscall.UTF16PtrFromString("Show Logs")
	app.logsButton = w32.CreateWindowEx(
		0,
		buttonClass,
		buttonText,
		w32.WS_VISIBLE|w32.WS_CHILD|w32.BS_PUSHBUTTON, // Removed WS_DISABLED - logs should always be available
		120, 165, 100, 38, // Moved up from 205 to 165
		hwnd, IDC_LOGS_BUTTON, hInstance, nil)
	log.Printf("Logs button created: %v", app.logsButton)
	// Set Aptos font for logs button
	w32.SendMessage(app.logsButton, w32.WM_SETFONT, uintptr(app.aptosFont), 1)

	// Create Run Now button
	runNowText, _ := syscall.UTF16PtrFromString("Run Now")
	app.runNowButton = w32.CreateWindowEx(
		0,
		buttonClass,
		runNowText,
		w32.WS_VISIBLE|w32.WS_CHILD|w32.BS_PUSHBUTTON,
		280, 165, 100, 38, // Moved up from 205 to 165
		hwnd, IDC_RUN_NOW_BUTTON, hInstance, nil)
	log.Printf("Run Now button created: %v", app.runNowButton)
	// Set Aptos font for run now button
	w32.SendMessage(app.runNowButton, w32.WM_SETFONT, uintptr(app.aptosFont), 1)

	log.Println("All controls created successfully")
}

// updateUI updates the Windows controls with current state
func (app *CimianStatusApp) updateUI() {
	app.state.mu.RLock()
	defer app.state.mu.RUnlock()

	if app.hwnd == 0 {
		return
	}

	// Update status text (dynamic) with proper redraw
	w32.SetWindowText(app.statusLabel, app.state.StatusText)
	w32.InvalidateRect(app.statusLabel, nil, true)
	w32.UpdateWindow(app.statusLabel)

	// Update detail text (last run time) with proper redraw
	if app.state.LastRunTime != "" && app.state.LastRunTime != "Never" {
		w32.SetWindowText(app.detailLabel, fmt.Sprintf("Last run: %s", app.state.LastRunTime))
	} else {
		w32.SetWindowText(app.detailLabel, "Last run: Never")
	}
	w32.InvalidateRect(app.detailLabel, nil, true)
	w32.UpdateWindow(app.detailLabel)

	// Update progress bar with enhanced visual feedback
	if app.state.ShowProgress && app.state.ProgressValue >= 0 {
		w32.SendMessage(app.progressBar, w32.PBM_SETPOS, uintptr(app.state.ProgressValue), 0)

		// Change progress bar color based on status
		if app.state.HasError {
			// Red for errors
			w32.SendMessage(app.progressBar, 0x409, 0, 0x004040FF) // Red (#FF4040)
		} else if app.state.ProgressValue == 100 {
			// Green for completion
			w32.SendMessage(app.progressBar, 0x409, 0, 0x0040FF40) // Green (#40FF40)
		} else {
			// Blue for in progress
			w32.SendMessage(app.progressBar, 0x409, 0, 0x00FF6B35) // Blue (#356BFF)
		}
	} else {
		// Show indeterminate progress by cycling 0-100 with smooth animation
		pos := int(time.Now().UnixMilli()/50) % 100 // Faster, smoother animation
		w32.SendMessage(app.progressBar, w32.PBM_SETPOS, uintptr(pos), 0)
		// Use standard blue for indeterminate progress
		w32.SendMessage(app.progressBar, 0x409, 0, 0x00FF6B35) // Blue (#356BFF)
	}

	// Logs are always available with the new logging system - remove conditional logic
	w32.EnableWindow(app.logsButton, true)

	// Change window title based on error state
	if app.state.HasError {
		w32.SetWindowText(app.hwnd, "Cimian Status - Error")
	} else {
		w32.SetWindowText(app.hwnd, "Cimian Status")
	}
}

// showLogs opens the log directory or specific log file
func (app *CimianStatusApp) showLogs() {
	app.state.mu.RLock()
	logPath := app.state.LogPath
	app.state.mu.RUnlock()

	logsBaseDir := `C:\ProgramData\ManagedInstalls\logs`

	if logPath == "" {
		// Find the latest timestamped session directory
		entries, err := os.ReadDir(logsBaseDir)
		if err == nil {
			var latestDir string
			var latestTime time.Time

			// Look for directories matching the new timestamped format: YYYY-MM-DD-HHMMSS
			for _, entry := range entries {
				if entry.IsDir() && len(entry.Name()) == 17 && entry.Name()[4] == '-' && entry.Name()[7] == '-' && entry.Name()[10] == '-' {
					// Parse the directory name as a timestamp (2006-01-02-150405 format)
					if dirTime, parseErr := time.Parse("2006-01-02-150405", entry.Name()); parseErr == nil {
						if latestDir == "" || dirTime.After(latestTime) {
							latestDir = entry.Name()
							latestTime = dirTime
						}
					}
				}
			}

			if latestDir != "" {
				// Open the entire session directory in Windows Explorer for better user experience
				sessionDirPath := filepath.Join(logsBaseDir, latestDir)
				exec.Command("explorer.exe", sessionDirPath).Start()
				return
			}
		}

		// Fallback to opening the main logs directory if no timestamped sessions found
		exec.Command("explorer.exe", logsBaseDir).Start()
	} else {
		// If we have a specific log path, open it with notepad
		exec.Command("notepad.exe", logPath).Start()
	}
}

// runNow executes the managedsoftwareupdate.exe process
func (app *CimianStatusApp) runNow() {
	// Disable the run now button during execution (safe on main thread)
	w32.EnableWindow(app.runNowButton, false)
	w32.SetWindowText(app.runNowButton, "ðŸ”„ Running...")
	w32.InvalidateRect(app.runNowButton, nil, true)
	w32.UpdateWindow(app.runNowButton)

	// Update status - only modify state
	app.state.mu.Lock()
	app.state.StatusText = "Running Cimian update check..."
	app.state.DetailText = "Please wait..."
	app.state.ShowProgress = true
	app.state.ProgressValue = 0
	app.state.HasError = false
	app.state.mu.Unlock()

	// Force UI update via message posting to avoid conflicts
	if app.hwnd != 0 {
		w32.PostMessage(app.hwnd, w32.WM_USER+1, 0, 0)
	}

	// Run the update in a goroutine to avoid blocking UI
	go app.executeUpdate()
}

// executeUpdate runs the managedsoftwareupdate.exe process
func (app *CimianStatusApp) executeUpdate() {
	defer func() {
		// Re-enable the run now button - do this via main thread
		if app.hwnd != 0 {
			w32.PostMessage(app.hwnd, w32.WM_USER+2, 0, 0) // Custom message to re-enable button
		}
	}()

	// Find the managedsoftwareupdate.exe executable
	execPath, err := app.findExecutable()
	if err != nil {
		app.state.mu.Lock()
		app.state.StatusText = "Error: Could not find managedsoftwareupdate.exe"
		app.state.DetailText = err.Error()
		app.state.HasError = true
		app.state.ShowProgress = false
		app.state.mu.Unlock()
		log.Printf("Error finding executable: %v", err)

		// Force UI update on main thread only
		if app.hwnd != 0 {
			w32.PostMessage(app.hwnd, w32.WM_USER+1, 0, 0)
		}
		return
	}

	// Simulate progress during the update process
	go app.simulateProgress()

	// Update status - only modify state, don't touch UI directly
	app.state.mu.Lock()
	app.state.StatusText = "Starting Cimian update process..."
	app.state.DetailText = "Launching managedsoftwareupdate.exe..."
	app.state.ProgressValue = 5
	app.state.ShowProgress = true
	app.state.mu.Unlock()

	// Force UI update on main thread only
	if app.hwnd != 0 {
		w32.PostMessage(app.hwnd, w32.WM_USER+1, 0, 0)
	}

	// Execute the signed binary directly with --auto flag
	// This runs the update process automatically without user interaction
	cmd := exec.Command(execPath, "--auto")

	log.Printf("Executing: %s --auto", execPath)

	// Start the process
	if err := cmd.Start(); err != nil {
		app.state.mu.Lock()
		app.state.StatusText = "Failed to start update process"
		app.state.DetailText = fmt.Sprintf("Execution failed: %v", err)
		app.state.HasError = true
		app.state.ShowProgress = false
		app.state.mu.Unlock()
		log.Printf("Error starting process: %v", err)

		// Force UI update on main thread only
		if app.hwnd != 0 {
			w32.PostMessage(app.hwnd, w32.WM_USER+1, 0, 0)
		}
		return
	}

	log.Printf("managedsoftwareupdate.exe started with PID: %d", cmd.Process.Pid)

	// Update status to indicate we're waiting for communication - only modify state
	app.state.mu.Lock()
	app.state.StatusText = "Cimian update process running..."
	app.state.DetailText = "Checking for available updates..."
	app.state.ProgressValue = 20
	app.state.mu.Unlock()

	// Force UI update on main thread only
	if app.hwnd != 0 {
		w32.PostMessage(app.hwnd, w32.WM_USER+1, 0, 0)
	}

	// Wait for the process to complete with timeout handling
	done := make(chan error, 1)
	go func() {
		done <- cmd.Wait()
	}()

	// Handle process completion or timeout
	select {
	case err = <-done:
		// Process completed normally - only modify state, no direct UI calls
		app.state.mu.Lock()
		if err != nil {
			app.state.StatusText = "Update completed with warnings"
			app.state.DetailText = fmt.Sprintf("Process finished: exit code %v", err)
			app.state.HasError = false // Don't treat all non-zero exits as errors
			app.state.ShowProgress = true
			app.state.ProgressValue = 100
			log.Printf("Update process completed with exit code: %v", err)
		} else {
			app.state.StatusText = "Update completed successfully"
			app.state.HasError = false
			app.state.ShowProgress = true
			app.state.ProgressValue = 100

			// Update last run time
			updateLastRunTime()
			app.state.LastRunTime = getLastRunTime()
			app.state.DetailText = fmt.Sprintf("Last successful run: %s", app.state.LastRunTime)

			log.Printf("Update process completed successfully")
		}
		app.state.mu.Unlock()

	case <-time.After(5 * time.Minute):
		// Process is taking too long, but don't kill it - just update status
		app.state.mu.Lock()
		app.state.StatusText = "Update process is taking longer than expected..."
		app.state.DetailText = "The process is still running in the background."
		app.state.ShowProgress = false
		app.state.mu.Unlock()
		log.Printf("Update process taking longer than 5 minutes, but continuing...")
	}

	// Force final UI update on main thread only
	if app.hwnd != 0 {
		w32.PostMessage(app.hwnd, w32.WM_USER+1, 0, 0)
	}
}

// simulateProgress provides visual feedback during the update process
func (app *CimianStatusApp) simulateProgress() {
	// Simulate progress over 30 seconds with realistic steps
	steps := []struct {
		progress int
		message  string
		delay    time.Duration
	}{
		{10, "Initializing update process...", 2 * time.Second},
		{25, "Checking catalog for updates...", 3 * time.Second},
		{40, "Downloading package information...", 4 * time.Second},
		{55, "Evaluating installed packages...", 3 * time.Second},
		{70, "Processing update requirements...", 4 * time.Second},
		{85, "Finalizing update operations...", 3 * time.Second},
		{95, "Completing update process...", 2 * time.Second},
	}

	for _, step := range steps {
		// Check if we should stop (process completed)
		app.state.mu.RLock()
		if !app.state.ShowProgress {
			app.state.mu.RUnlock()
			return
		}
		app.state.mu.RUnlock()

		time.Sleep(step.delay)

		// Update progress
		app.state.mu.Lock()
		if app.state.ShowProgress { // Double-check we're still running
			app.state.ProgressValue = step.progress
			app.state.DetailText = step.message
		}
		app.state.mu.Unlock()

		// Force UI update
		if app.hwnd != 0 {
			w32.PostMessage(app.hwnd, w32.WM_USER+1, 0, 0)
		}
	}
}

// findExecutable locates the managedsoftwareupdate.exe executable
func (app *CimianStatusApp) findExecutable() (string, error) {
	// Look for managedsoftwareupdate.exe in common locations, prioritizing signed binaries
	possiblePaths := []string{
		// First check the installed location
		filepath.Join(os.Getenv("ProgramFiles"), "Cimian", "managedsoftwareupdate.exe"),
		// Then check the local release directory (signed binaries) - various possible locations
		filepath.Join(filepath.Dir(os.Args[0]), "..", "..", "release", "x64", "managedsoftwareupdate.exe"),
		filepath.Join(filepath.Dir(os.Args[0]), "release", "x64", "managedsoftwareupdate.exe"),
		filepath.Join(filepath.Dir(os.Args[0]), "..", "release", "x64", "managedsoftwareupdate.exe"),
		// Check bin directory (build outputs)
		filepath.Join(filepath.Dir(os.Args[0]), "..", "..", "bin", "x64", "managedsoftwareupdate.exe"),
		filepath.Join(filepath.Dir(os.Args[0]), "bin", "x64", "managedsoftwareupdate.exe"),
		filepath.Join(filepath.Dir(os.Args[0]), "..", "bin", "x64", "managedsoftwareupdate.exe"),
		// Check same directory as this executable
		filepath.Join(filepath.Dir(os.Args[0]), "managedsoftwareupdate.exe"),
		// Check current working directory
		"managedsoftwareupdate.exe",
	}

	for _, path := range possiblePaths {
		// Try both as-is and with absolute path resolution
		testPaths := []string{path}
		if absPath, err := filepath.Abs(path); err == nil && absPath != path {
			testPaths = append(testPaths, absPath)
		}

		for _, testPath := range testPaths {
			if _, err := os.Stat(testPath); err == nil {
				log.Printf("Found managedsoftwareupdate.exe at: %s", testPath)
				return testPath, nil
			}
		}
	}

	return "", fmt.Errorf("managedsoftwareupdate.exe not found in any expected location. Searched: %v", possiblePaths)
}

func main() {
	// Write to stderr to ensure we can see output even if stdout is redirected
	log.SetOutput(os.Stderr)
	log.Println("CimianStatus starting...")

	// Create the application
	statusApp := &CimianStatusApp{
		backgroundMode: isBackgroundMode(),
		className:      "CimianStatusWindow",
		state: &StatusState{
			StatusText:   "Cimian Status Ready",
			ShowProgress: false,
			LastRunTime:  getLastRunTime(),
		},
	}

	log.Printf("Background mode: %v", statusApp.backgroundMode)

	// Set initial detail text with last run time
	if statusApp.state.LastRunTime == "Never" {
		statusApp.state.DetailText = "Last run: Never"
	} else {
		statusApp.state.DetailText = fmt.Sprintf("Last run: %s", statusApp.state.LastRunTime)
	}

	// Initialize context
	statusApp.ctx, statusApp.cancel = context.WithCancel(context.Background())

	// Start the TCP server for CLI communication
	log.Println("Starting TCP server...")
	if err := statusApp.StartTCPServer(); err != nil {
		log.Fatalf("Failed to start TCP server: %v", err)
	}
	log.Println("TCP server started successfully")

	// Start the Windows GUI if not in background mode
	if !statusApp.backgroundMode {
		log.Println("Starting Windows GUI...")
		if err := statusApp.StartWindowsGUI(); err != nil {
			log.Fatalf("Failed to start Windows GUI: %v", err)
		}
	} else {
		log.Println("Running in background mode, waiting for context cancellation...")
		// In background mode, just wait for context cancellation
		<-statusApp.ctx.Done()
	}

	log.Println("CimianStatus shutting down...")
}

// isBackgroundMode detects if we're running in SYSTEM context or at login screen
func isBackgroundMode() bool {
	return os.Getenv("USERNAME") == "SYSTEM" || os.Getenv("USERPROFILE") == ""
}

// getLastRunTime reads the last successful run time from file
func getLastRunTime() string {
	lastRunFile := filepath.Join(os.Getenv("ProgramData"), "ManagedInstalls", "LastRunTime.txt")
	if data, err := os.ReadFile(lastRunFile); err == nil {
		return strings.TrimSpace(string(data))
	}
	return "Never"
}

// updateLastRunTime saves the current time as the last successful run time
func updateLastRunTime() {
	currentTime := time.Now().Format("2006-01-02 15:04:05")
	lastRunFile := filepath.Join(os.Getenv("ProgramData"), "ManagedInstalls", "LastRunTime.txt")
	os.MkdirAll(filepath.Dir(lastRunFile), 0755)
	os.WriteFile(lastRunFile, []byte(currentTime), 0644)
}

// StartWindowsGUI initializes and shows the Windows GUI
func (app *CimianStatusApp) StartWindowsGUI() error {
	log.Println("Initializing Windows GUI...")
	hInstance := w32.GetModuleHandle("")
	log.Printf("Module handle: %v", hInstance)

	// Register window class with icon loading
	log.Println("Registering window class...")
	var wc w32.WNDCLASSEX
	wc.Size = uint32(unsafe.Sizeof(wc))
	wc.Style = w32.CS_HREDRAW | w32.CS_VREDRAW | w32.CS_DBLCLKS // Add double-click support
	wc.WndProc = syscall.NewCallback(func(hwnd w32.HWND, msg uint32, wParam uintptr, lParam uintptr) uintptr {
		return app.wndProc(hwnd, msg, wParam, lParam)
	})
	wc.Instance = hInstance
	wc.Cursor = w32.LoadCursor(0, w32.MakeIntResource(w32.IDC_ARROW))
	wc.Background = w32.HBRUSH(w32.COLOR_BTNFACE + 1) // Modern dialog background
	className, _ := syscall.UTF16PtrFromString(app.className)
	wc.ClassName = className

	// Load custom icon - prioritize ICO format
	iconLoaded := false

	// Get the directory where the executable is located
	execDir := filepath.Dir(os.Args[0])

	// Try various paths for icon files, prioritizing ICO format
	iconPaths := []string{
		filepath.Join(execDir, "cimian.ico"),                                  // Same directory as exe (ICO)
		filepath.Join(execDir, "..", "..", "cmd", "cimistatus", "cimian.ico"), // Source location (ICO)
		"cmd\\cimistatus\\cimian.ico",                                         // Relative from working directory (ICO)
		"cimian.ico",                                                          // Current working directory (ICO)
		filepath.Join(execDir, "icon.ico"),                                    // Fallback to old name (ICO)
		filepath.Join(execDir, "..", "..", "cmd", "cimistatus", "icon.ico"),   // Fallback source location (ICO)
		"cmd\\cimistatus\\icon.ico",                                           // Fallback relative from working directory (ICO)
		"icon.ico",                                                            // Fallback current working directory (ICO)
	}

	user32 := syscall.NewLazyDLL("user32.dll")
	loadImage := user32.NewProc("LoadImageW")

	for _, iconPath := range iconPaths {
		if _, err := os.Stat(iconPath); err == nil {
			iconPathW, _ := syscall.UTF16PtrFromString(iconPath)
			log.Printf("Attempting to load icon from: %s", iconPath)

			var ret uintptr

			// Load icon directly (works best with ICO files)
			ret, _, _ = loadImage.Call(
				uintptr(0), // hInst - NULL for loading from file
				uintptr(unsafe.Pointer(iconPathW)),
				uintptr(1),          // IMAGE_ICON
				uintptr(32),         // desired width
				uintptr(32),         // desired height
				uintptr(0x00000010), // LR_LOADFROMFILE
			)

			if ret != 0 {
				wc.Icon = w32.HICON(ret)
				log.Printf("Successfully loaded large icon from: %s", iconPath)

				// Load small icon (16x16)
				ret2, _, _ := loadImage.Call(
					uintptr(0), // hInst - NULL for loading from file
					uintptr(unsafe.Pointer(iconPathW)),
					uintptr(1),          // IMAGE_ICON
					uintptr(16),         // desired width
					uintptr(16),         // desired height
					uintptr(0x00000010), // LR_LOADFROMFILE
				)

				if ret2 != 0 {
					wc.IconSm = w32.HICON(ret2)
					log.Printf("Successfully loaded small icon from: %s", iconPath)
				} else {
					// Use the large icon for small icon too
					wc.IconSm = w32.HICON(ret)
					log.Printf("Using large icon as small icon fallback")
				}
				iconLoaded = true
				break
			} else {
				log.Printf("Failed to load icon from: %s", iconPath)
			}
		} else {
			log.Printf("Icon file not found: %s", iconPath)
		}
	}

	if !iconLoaded {
		log.Println("Using default Windows application icon")
		// Use default application icon as fallback
		wc.Icon = w32.LoadIcon(0, w32.MakeIntResource(w32.IDI_APPLICATION))
		wc.IconSm = w32.LoadIcon(0, w32.MakeIntResource(w32.IDI_APPLICATION))
	}

	if w32.RegisterClassEx(&wc) == 0 {
		return fmt.Errorf("failed to register window class")
	}
	log.Println("Window class registered successfully")

	// Create window with modern sizing
	log.Println("Creating window...")
	classNamePtr, _ := syscall.UTF16PtrFromString(app.className)
	titlePtr, _ := syscall.UTF16PtrFromString("Cimian Status")
	app.hwnd = w32.CreateWindowEx(
		w32.WS_EX_APPWINDOW,
		classNamePtr,
		titlePtr,
		w32.WS_OVERLAPPED|w32.WS_CAPTION|w32.WS_SYSMENU|w32.WS_MINIMIZEBOX,
		w32.CW_USEDEFAULT, w32.CW_USEDEFAULT, 520, 320, // Reduced height from 390 to 320
		0, 0, hInstance, nil)

	if app.hwnd == 0 {
		return fmt.Errorf("failed to create window")
	}
	log.Printf("Window created successfully with handle: %v", app.hwnd)

	// Set window icon explicitly for crisp display
	if wc.Icon != 0 {
		// Set both large and small window icons for crisp display at all sizes
		w32.SendMessage(app.hwnd, w32.WM_SETICON, 1, uintptr(wc.Icon))   // ICON_BIG (32x32)
		w32.SendMessage(app.hwnd, w32.WM_SETICON, 0, uintptr(wc.IconSm)) // ICON_SMALL (16x16)
		log.Println("Window icons set explicitly for crisp display")
	}

	// Show and update window
	log.Println("Showing window...")
	w32.ShowWindow(app.hwnd, w32.SW_SHOW)
	w32.UpdateWindow(app.hwnd)
	log.Println("Window shown and updated")

	// Start UI update timer in a goroutine
	go app.uiUpdateLoop()

	// Message loop
	log.Println("Starting message loop...")
	var msg w32.MSG
	for {
		bRet := w32.GetMessage(&msg, 0, 0, 0)
		if bRet == 0 || bRet == -1 { // WM_QUIT or error
			break
		}
		w32.TranslateMessage(&msg)
		w32.DispatchMessage(&msg)
	}
	log.Println("Message loop ended")

	return nil
}

// uiUpdateLoop periodically updates the UI elements
func (app *CimianStatusApp) uiUpdateLoop() {
	ticker := time.NewTicker(2000 * time.Millisecond) // Even slower to prevent conflicts
	defer ticker.Stop()

	for {
		select {
		case <-app.ctx.Done():
			return
		case <-ticker.C:
			// Only update if we're not currently in a critical operation
			app.state.mu.RLock()
			showProgress := app.state.ShowProgress
			app.state.mu.RUnlock()

			// Only post UI updates when safe to do so
			if app.hwnd != 0 && showProgress {
				w32.PostMessage(app.hwnd, w32.WM_USER+1, 0, 0)
			}
		}
	}
} // StartTCPServer starts the TCP server for CLI communication
func (app *CimianStatusApp) StartTCPServer() error {
	listener, err := net.Listen("tcp", "127.0.0.1:19847")
	if err != nil {
		return fmt.Errorf("failed to create TCP listener: %v", err)
	}

	app.tcpListener = listener
	go app.handleTCPConnections()

	log.Printf("CimianStatus TCP server listening on %s", listener.Addr().String())
	return nil
}

// handleTCPConnections accepts and processes TCP connections from CLI
func (app *CimianStatusApp) handleTCPConnections() {
	for {
		select {
		case <-app.ctx.Done():
			return
		default:
			conn, err := app.tcpListener.Accept()
			if err != nil {
				select {
				case <-app.ctx.Done():
					return
				default:
					log.Printf("TCP accept error: %v", err)
					continue
				}
			}

			go app.handleConnection(conn)
		}
	}
}

// handleConnection processes a single TCP connection
func (app *CimianStatusApp) handleConnection(conn net.Conn) {
	defer conn.Close()

	scanner := bufio.NewScanner(conn)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.TrimSpace(line) == "" {
			continue
		}

		var msg StatusMessage
		if err := json.Unmarshal([]byte(line), &msg); err != nil {
			log.Printf("Failed to unmarshal message: %v", err)
			continue
		}

		app.processMessage(msg)
	}

	if err := scanner.Err(); err != nil {
		log.Printf("Scanner error: %v", err)
	}
}

// processMessage handles incoming status messages and updates the UI
func (app *CimianStatusApp) processMessage(msg StatusMessage) {
	app.state.mu.Lock()
	defer app.state.mu.Unlock()

	switch msg.Type {
	case "statusMessage":
		app.state.StatusText = msg.Data
		app.state.HasError = msg.Error
		log.Printf("Status: %s (Error: %v)", msg.Data, msg.Error)

	case "detailMessage":
		app.state.DetailText = msg.Data
		log.Printf("Detail: %s", msg.Data)

	case "percentProgress":
		if msg.Percent >= 0 {
			app.state.ProgressValue = msg.Percent
			app.state.ShowProgress = true
		} else {
			app.state.ShowProgress = false
		}
		log.Printf("Progress: %d%%", msg.Percent)

	case "displayLog":
		app.state.LogPath = msg.Data
		app.state.LogAvailable = true
		log.Printf("Log available: %s", msg.Data)

	case "quit":
		log.Println("Received quit message from managedsoftwareupdate")
		app.cancel()
		if app.hwnd != 0 {
			w32.PostMessage(app.hwnd, w32.WM_CLOSE, 0, 0)
		}
		return
	}

	// Schedule UI update on main thread - use a timer to debounce rapid updates
	go func() {
		time.Sleep(250 * time.Millisecond) // Small delay to debounce rapid messages
		if app.hwnd != 0 {
			w32.PostMessage(app.hwnd, w32.WM_USER+1, 0, 0)
		}
	}()
}
